{"searchDocs":[{"title":"Pipeline","type":0,"sectionRef":"#","url":"/planck/api/Pipeline","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#properties","content":" ","version":null,"tagName":"h2"},{"title":"Startup​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#Startup","content":"&lt;/&gt; Pipeline.Startup: Pipeline A Pipeline containing the PreStartup, Startup, and PostStartup phases. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#new","content":"&lt;/&gt; Pipeline.new(name: string?) → () Creates a new Pipeline, with an optional name to use for debugging. When no name is provided, the script and line number will be used.  ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#insert","content":"&lt;/&gt; Pipeline:insert(phase: Phase) → Pipeline Adds a Phase to the Pipeline, ordering it implicitly.  ","version":null,"tagName":"h3"},{"title":"insertAfter​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#insertAfter","content":"&lt;/&gt; Pipeline:insertAfter( phase: Phase, after: Phase ) → Pipeline Adds a Phase to the Pipeline after another Phase, ordering it explicitly.  ","version":null,"tagName":"h3"},{"title":"insertBefore​","type":1,"pageTitle":"Pipeline","url":"/planck/api/Pipeline#insertBefore","content":"&lt;/&gt; Pipeline:insertBefore( phase: Phase, before: Phase ) → Pipeline Adds a Phase to the Pipeline before another Phase, ordering it explicitly. ","version":null,"tagName":"h3"},{"title":"Phase","type":0,"sectionRef":"#","url":"/planck/api/Phase","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#properties","content":" ","version":null,"tagName":"h2"},{"title":"PreStartup​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#PreStartup","content":"&lt;/&gt; Phase.PreStartup: Phase Runs before the Startup Phase.  ","version":null,"tagName":"h3"},{"title":"Startup​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#Startup","content":"&lt;/&gt; Phase.Startup: Phase This Phase will run once, the first time the Scheduler is ran, before any other Phases are ran.  ","version":null,"tagName":"h3"},{"title":"PostStartup​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#PostStartup","content":"&lt;/&gt; Phase.PostStartup: Phase Runs after the Startup phase. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Phase","url":"/planck/api/Phase#new","content":"&lt;/&gt; Phase.new(name: string?) → () Creates a new Phase, with an optional name to use for debugging. When no name is provided, the script and line number will be used. ","version":null,"tagName":"h3"},{"title":"Conditions","type":0,"sectionRef":"#","url":"/planck/api/Conditions","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Conditions","url":"/planck/api/Conditions#functions","content":" ","version":null,"tagName":"h2"},{"title":"timePassed​","type":1,"pageTitle":"Conditions","url":"/planck/api/Conditions#timePassed","content":"&lt;/&gt; Conditions.timePassed( time: number-- Time in seconds ) → hasTimePassed() → boolean A Throttle condition which checks whether the amount of time given has passed or not.  ","version":null,"tagName":"h3"},{"title":"runOnce​","type":1,"pageTitle":"Conditions","url":"/planck/api/Conditions#runOnce","content":"&lt;/&gt; Conditions.runOnce() → hasRanOnce() → boolean Checks whether the condition has been called once before  ","version":null,"tagName":"h3"},{"title":"onEvent​","type":1,"pageTitle":"Conditions","url":"/planck/api/Conditions#onEvent","content":"&lt;/&gt; Conditions.onEvent( instance: RBXScriptSignal | Instance | SignalLike&lt;...any&gt; | GenericTable | (( Callback&lt;U...&gt;, ...any ) → ...any), event: (RBXScriptSignal | string | (...any) → ())? ) → ( hasNewEvent() → boolean, collectEvents() → () → ( number, U... ), getDisconnectFn() → () → () ) Checks for any new events and allows for the collection of those events. Read OnEvent for more information.  ","version":null,"tagName":"h3"},{"title":"isNot​","type":1,"pageTitle":"Conditions","url":"/planck/api/Conditions#isNot","content":"&lt;/&gt; Conditions.isNot( condition: () → boolean, ...: any ) → inverseCondition() → boolean Inverses a given condition. ","version":null,"tagName":"h3"},{"title":"Designing with Planck","type":0,"sectionRef":"#","url":"/planck/docs/design/","content":"","keywords":"","version":"Next"},{"title":"Off By A Frame Issues​","type":1,"pageTitle":"Designing with Planck","url":"/planck/docs/design/#off-by-a-frame-issues","content":" One of the most frequent issues we will be addressing are 'off-by-a-frame' bugs. While your systems and game as a whole should be able to function still with these issues present, the effect of it is visible latency in your game.  This was briefly introduced in Introduction under 'Does any of this really matter?'.  Let's say we have systemA and systemB. systemAmodifies data in our world which systemB depends on. If systemA runs after systemB, then systemB will have to wait a whole frame for the modifications to be made.  When a system has to wait a whole frame for an operation it depends on, we introduce latency into our game. This latency has the potential to be visible to players, who call it lag.  The best way to address this is by assigning systemA andsystemB to different Phases, with systemA's Phase runningbefore systemB's Phase.  We will go into detail on when to create a Phase, what Phases systems should be assigned to, and more later on.  ","version":"Next","tagName":"h2"},{"title":"Credits​","type":1,"pageTitle":"Designing with Planck","url":"/planck/docs/design/#credits","content":" These design guides were inspired and influenced by the Flecs and Matter documentation.  ","version":"Next","tagName":"h2"},{"title":"What's Next?​","type":1,"pageTitle":"Designing with Planck","url":"/planck/docs/design/#whats-next","content":" Let's continue where we left off and talk about Phases. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/planck/docs/getting_started/introduction","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/planck/docs/getting_started/introduction#installation","content":" Planck is available for installation via Wally or as a .rbxm in GitHub Releases.  To install for wally, you can do:  [dependencies] Planck = &quot;yetanotherclown/planck@0.2.0-rc.2&quot;   It's suggested you get it installed before we continue, following along while reading will help you better understand Planck.  ","version":"Next","tagName":"h2"},{"title":"What is Planck?​","type":1,"pageTitle":"Introduction","url":"/planck/docs/getting_started/introduction#what-is-planck","content":" Planck is a standalone scheduler, which allows you to execute code on specific events, with certain conditions, and in a particular order.  This scheduler is library agnostic, which means that it doesn't matter which ECS library your using or if you're even using an ECS. You can use this with Jecs, Matter, ECR, and other Luau ECS Libraries.  ","version":"Next","tagName":"h2"},{"title":"Does any of this really matter?​","type":1,"pageTitle":"Introduction","url":"/planck/docs/getting_started/introduction#does-any-of-this-really-matter","content":" Yes, and no. Your ECS code should be able to run in any order, without any conditions, and without concern for which event it's running on, as long as it is running.  The order of execution, and conditions both serve to optimize your code. Some systems don't need to run every frame, which is why we have conditions. And the actual order of execution is to reduce latency between changes and effects in your ECS world.  Let's say we have systemA and systemB. systemA modifies data in our world which systemB depends on. If systemA runs after systemB, then systemB will have to wait a whole frame for the modifications to be made. This is called being off-by-a-frame, and this is why we care about the order of execution.  ","version":"Next","tagName":"h2"},{"title":"What's Next?​","type":1,"pageTitle":"Introduction","url":"/planck/docs/getting_started/introduction#whats-next","content":" You may not completely understand what's written above. That's fine.  These concepts will continue to be explained as you learn more about Planck. For now, learn about the basics of Planck, such as the Scheduler, Systems, and Phases. These are the very basics that are needed to setup and use Planck. Consider them the 'bare minium' required to build a game with Planck.  → The Scheduler  ","version":"Next","tagName":"h2"},{"title":"Inspiration​","type":1,"pageTitle":"Introduction","url":"/planck/docs/getting_started/introduction#inspiration","content":" Planck's API design is heavily influenced by the Bevy Engine, with Schedules, RunConditions, and more. Planck also draws inspiration from Flecs for Pipelines and Phases.  We're combining the simple, and beloved API of Bevy with the concept of Pipelines and Phases. ","version":"Next","tagName":"h2"},{"title":"Phases and Pipelines","type":0,"sectionRef":"#","url":"/planck/docs/design/phases-and-pipelines","content":"","keywords":"","version":"Next"},{"title":"Phases​","type":1,"pageTitle":"Phases and Pipelines","url":"/planck/docs/design/phases-and-pipelines#phases","content":" When you're working with custom Phases, it is important to try and reduce the complexity of your order of execution. Too many Phases could prove difficult to work with if they are not managed properly.  When you have multiple related phases, which means phases that all run on the same event, and in order of one after another, you should create a Pipeline to manage them.  ","version":"Next","tagName":"h2"},{"title":"Pipelines​","type":1,"pageTitle":"Phases and Pipelines","url":"/planck/docs/design/phases-and-pipelines#pipelines","content":" Pipelines are ordered groups of Phases, they make it easy to work with large collections of Phases when they run on the same event.  An example of a Pipeline would be the built-in RunService.HeartbeatPipeline, appropriately named 'Main'.  First -&gt; PreUpdate -&gt; Update -&gt; PostUpdate -&gt; Last  All of these Phases run on the same event, RunService.Heartbeat. And they are explicitly ordered to run one after another.  By grouping Phases like this, we can manage them more effectively. Here's an example of what I mean:  local Phase = Planck.Phase local Pipeline = Planck.Pipeline local Scheduler = Planck.Scheduler local PreUpdate = Phase.new() local Update = Phase.new() local PostUpdate = Phase.new() local UpdatePipeline = Pipeline.new() :insert(PreUpdate) :insert(Update) :insert(PostUpdate) local scheduler = scheduler.new(world) :insert(UpdatePipeline, RunService, &quot;Heartbeat&quot;)   Instead of using insert on every Phase, we instead just insert the Pipeline and all of the Phases in the Pipeline are inserted on the same event.  ","version":"Next","tagName":"h2"},{"title":"What's Next​","type":1,"pageTitle":"Phases and Pipelines","url":"/planck/docs/design/phases-and-pipelines#whats-next","content":" Let's look into Conditions, which allow us to set strict conditions on when a System, Phase, or Pipeline can run.  It's important to note that conditions do not run any code. When a Phase is executed, it will check the conditions on itself and it's systems, if the conditions are met, the Phase or System will run. ","version":"Next","tagName":"h2"},{"title":"Order of Execution","type":0,"sectionRef":"#","url":"/planck/docs/getting_started/order","content":"","keywords":"","version":"Next"},{"title":"The Algorithm​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#the-algorithm","content":" Planck uses Kahn's algorithm to determine the order your Pipelines and Phases will run in. Whereas systems are just ordered by the order of insertion into the Scheduler.  ","version":"Next","tagName":"h2"},{"title":"Key Terms​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#key-terms","content":" It is important to understand the following terms while explaining how ordering works:  A dependency is any Phase/Pipeline another Phase/Pipeline depends on.A dependent if the Phase/Pipeline that depends on another Phase/Pipeline.  This looks like, insertAfter(dependent, dependency) or insertBefore(dependent, dependency).  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#steps","content":" And now to explain how the algorithm works, here are the steps it takes  Start with the first Phase/Pipeline insertedIf this Phase/Pipeline has any dependency, skip it and move onto the next one.Add this Phase/Pipeline to the orderIf this Phase/Pipeline has any dependents, repeat this process in order of insertion for each dependent Phase/Pipeline.Move onto the next Phase/Pipeline.  ","version":"Next","tagName":"h3"},{"title":"Pipelines and Phases​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#pipelines-and-phases","content":" ","version":"Next","tagName":"h2"},{"title":"Built-in​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#built-in","content":" It is important to note that all of the built-in Phases you see will run in the order they appear in the Documentation. Each of these Phases represent a single sync point within a single frame of your game.  PreRender -&gt; PreAnimation -&gt; PreSimulation -&gt; PostSimulation -&gt; UpdatePipeline  ","version":"Next","tagName":"h3"},{"title":"Custom​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#custom","content":" When using custom Pipelines or Phases, Scheduler:insert() will order them by order of insertion. This is done by making the last added Phase/Pipeline a dependency of the latest Phase/Pipeline.  For example,  local scheduler = Scheduler.new() :insert(phaseA) :insert(phaseB) :runAll()   phaseA will run before phaseB when we do scheduler:runAll(). In this scenario, phaseA is a dependency of phaseB, where phaseAmust run before phaseB.  Systems don't have any dependencies, they are only ordered by insertion within a phase,  local scheduler = Scheduler.new() :addSystem(systemA) :addSystem(systemB) :runAll()   So, systemA runs before systemB.  You can create dependencies for Phases/Pipelines explicitly too by usingScheduler:insertAfter() and Scheduler:insertBefore().  local scheduler = Scheduler.new() :insert(phaseA) :insertAfter(phaseB, phaseA) :runAll()   phaseB now depends on phaseA, meaning it can't run until phaseA runs.  Scheduler:insertBefore(phaseB, phaseA) works similarly too, except phaseB can only run before phaseA.  ","version":"Next","tagName":"h3"},{"title":"With Events​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#with-events","content":" Phases and Pipelines are grouped together into Groups. Each Event is it's own group, and then we also have the Default group.  When using insertAfter() or insertBefore(), the dependent Phase/Pipeline will inherit the event of it's dependency, joining that group. Using insert() will always add a Phase/Pipeline to the Default group when no event is specified.  Phases/Pipelines in different groups are not ordered together, instead each group is isolated and their Phases/Pipelines will run in an order within the group.  local scheduler = Scheduler.new() :insert(pipelineA, RunService.Heartbeat) :insertAfter(pipelineB, RunService.PostSimulation) :runAll()   This code will create two groups: Heartbeat and PostSimulation. When Scheduler:runAll() runs, first it will process every Phase or Pipeline on the Heartbeat group. And then, it will process every Phase or Pipeline on thePostSimulation group.  ","version":"Next","tagName":"h3"},{"title":"Whats Next?​","type":1,"pageTitle":"Order of Execution","url":"/planck/docs/getting_started/order#whats-next","content":" You're ready to begin building a game with Planck!  Checkout the setup guides for:  MatterJecs  Already read those guides? Already have a game with Planck? Learn how to properly design Pipelines, Phases, and Systems.  → The Order of Execution ","version":"Next","tagName":"h2"},{"title":"Phases","type":0,"sectionRef":"#","url":"/planck/docs/getting_started/phases","content":"","keywords":"","version":"Next"},{"title":"Built-in Phases​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#built-in-phases","content":" Planck provides built-in Phases like Startup Phases and also provides a Plugin for Roblox RunService that adds Pipelines and Phases for each RunService Event.  While you're just getting started, it is suggested that you use these built-in phases for now. You will learn about deciding to make a Phase (and Pipelines) later.  ","version":"Next","tagName":"h2"},{"title":"Startup Phases​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#startup-phases","content":" Startup Phases are a special kind of Phase. Planck will only run these systems once, and before any other system is ran.  PreStartupStartupPostStartup  local Planck = require(&quot;@packages/Planck&quot;) local Phase = Planck.Phase local PreStartup = Phase.PreStartup local Startup = Phase.Startup local PostStartup = Phase.PostStartup   These Phases are useful for initialization work that you need to do once, and before you start your game loop.  ","version":"Next","tagName":"h3"},{"title":"RunService Phases Plugin​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#runservice-phases-plugin","content":" Planck provides a plugin that adds built-in Phases and Pipelines for each RunService event.  ","version":"Next","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#installation","content":" With Wally,  [dependencies] PlanckRunService = &quot;yetanotherclown/planck-runservice@0.2.0-rc.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Pipelines​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#pipelines","content":" Each RunService Event is now it's own Pipeline,  PreRenderPreAnimationPreSimulationPostSimulationHeartbeat  tip You might be more familiar with the old names for some of these events. PreRender is equivalent to RenderSteppedPreSimulation is equivalent to Stepped  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Pipelines = PlanckRunService.Pipelines local PreRender = Pipelines.PreRender local PreAnimation = Pipelines.PreAnimation local PreSimulation = Pipelines.PreSimulation local PostSimulation = Pipelines.PostSimulation local Heartbeat = Pipelines.Heartbeat   ","version":"Next","tagName":"h3"},{"title":"Phases​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#phases-1","content":" And it's own Phase, with the exception of Heartbeat which has many Phases.  Event\tPhasePreRender\tPreRender PreAnimation\tPreAnimation PreSimulation\tPreSimulation PostSimulation\tPostSimulation Heartbeat\tUpdate  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Phases = PlanckRunService.Phases local PreRender = Phases.PreRender local PreAnimation = Phases.PreAnimation local PreSimulation = Phases.PreSimulation local PostSimulation = Phases.PostSimulation local Update = Phases.Update   ","version":"Next","tagName":"h3"},{"title":"More Update Phases​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#more-update-phases","content":" RunService.Heartbeat isn't just a single Phase, instead its composed of many Phases. This is because the Update Phases are where most of your game's logic will run on, so we believe it's important that you can express the order of execution easily right out of the box.  FirstPreUpdateUpdatePostUpdateLast  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Phases = PlanckRunService.Phases local First = Phases.First local PreUpdate = Phases.PreUpdate local Update = Phases.Update local PostUpdate = Phases.PostUpdate local Last = Phases.Last   ","version":"Next","tagName":"h3"},{"title":"What's Next?​","type":1,"pageTitle":"Phases","url":"/planck/docs/getting_started/phases#whats-next","content":" Now that we know about Phases, it's time to learn how to explicitly define our order of execution.  → The Order of Execution ","version":"Next","tagName":"h2"},{"title":"Scheduler","type":0,"sectionRef":"#","url":"/planck/api/Scheduler","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#types","content":" ","version":null,"tagName":"h2"},{"title":"SystemFn​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#SystemFn","content":"&lt;/&gt; type SystemFn = ((U...) → any)   ","version":null,"tagName":"h3"},{"title":"SystemTable​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#SystemTable","content":"&lt;/&gt; interface SystemTable { system: SystemFn&lt;U...&gt; phase: Phase? [any]: any }   ","version":null,"tagName":"h3"},{"title":"System​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#System","content":"&lt;/&gt; type System = SystemFn&lt;U...&gt; | SystemTable&lt;U...&gt;  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#new","content":"&lt;/&gt; Scheduler.new(args: U...) → () Creates a new Scheduler, the args passed will be passed to any System anytime it is ran by the Scheduler.  ","version":null,"tagName":"h3"},{"title":"addPlugin​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addPlugin","content":"&lt;/&gt; Scheduler:addPlugin(plugin: PlanckPlugin) → () Initializes a plugin with the scheduler, see the Plugin Docs for more information.  ","version":null,"tagName":"h3"},{"title":"getDeltaTime​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#getDeltaTime","content":"&lt;/&gt; Scheduler:getDeltaTime() → number Returns the time since the system was ran last. This must be used within a registered system.  ","version":null,"tagName":"h3"},{"title":"run​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#run","content":"&lt;/&gt; Scheduler:run(phase: Phase) → Scheduler Runs all Systems tagged with the Phase in order.  ","version":null,"tagName":"h3"},{"title":"run​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#run","content":"&lt;/&gt; Scheduler:run(pipeline: Pipeline) → Scheduler Runs all Systems tagged with any Phase within the Pipeline in order.  ","version":null,"tagName":"h3"},{"title":"run​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#run","content":"&lt;/&gt; Scheduler:run(system: System) → Scheduler Runs the System, passing in the arguments of the Scheduler, U....  ","version":null,"tagName":"h3"},{"title":"runAll​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#runAll","content":"&lt;/&gt; Scheduler:runAll() → Scheduler Runs all Systems within order. NOTE When you add a Pipeline or Phase with an event, it will be grouped with other Pipelines/Phases on that event. Otherwise, it will be added to the default group. When not running systems on Events, such as with the runAll method, the Default group will be ran first, and then each Event Group in the order created. Pipelines/Phases in these groups are still ordered by their dependencies and by the order of insertion.  ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insert","content":"&lt;/&gt; Scheduler:insert(phase: Phase) → Scheduler Initializes the Phase within the Scheduler, ordering it implicitly by setting it as a dependent of the previous Phase/Pipeline.  ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insert","content":"&lt;/&gt; Scheduler:insert(pipeline: Pipeline) → Scheduler Initializes the Pipeline and it's Phases within the Scheduler, ordering the Pipeline implicitly by setting it as a dependent of the previous Phase/Pipeline.  ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insert","content":"&lt;/&gt; Scheduler:insert( phase: Phase, instance: Instance | EventLike, event: string | EventLike ) → Scheduler Initializes the Phase within the Scheduler, ordering it implicitly by setting it as a dependent of the previous Phase/Pipeline, and scheduling it to be ran on the specified event. local myScheduler = Scheduler.new() :insert(myPhase, RunService, &quot;Heartbeat&quot;)   ","version":null,"tagName":"h3"},{"title":"insert​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insert","content":"&lt;/&gt; Scheduler:insert( pipeline: Pipeline, instance: Instance | EventLike, event: string | EventLike ) → Scheduler Initializes the Pipeline and it's Phases within the Scheduler, ordering the Pipeline implicitly by setting it as a dependent of the previous Phase/Pipeline, and scheduling it to be ran on the specified event. local myScheduler = Scheduler.new() :insert(myPipeline, RunService, &quot;Heartbeat&quot;)   ","version":null,"tagName":"h3"},{"title":"insertAfter​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insertAfter","content":"&lt;/&gt; Scheduler:insertAfter( phase: Phase, after: Phase | Pipeline ) → Scheduler Initializes the Phase within the Scheduler, ordering it explicitly by setting the after Phase/Pipeline as a dependent.  ","version":null,"tagName":"h3"},{"title":"insertAfter​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insertAfter","content":"&lt;/&gt; Scheduler:insertAfter( pipeline: Pipeline, after: Phase | Pipeline ) → Scheduler Initializes the Pipeline and it's Phases within the Scheduler, ordering the Pipeline explicitly by setting the after Phase/Pipeline as a dependent.  ","version":null,"tagName":"h3"},{"title":"insertBefore​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insertBefore","content":"&lt;/&gt; Scheduler:insertBefore( phase: Phase, before: Phase | Pipeline ) → Scheduler Initializes the Phase within the Scheduler, ordering it explicitly by setting the before Phase/Pipeline as a dependency.  ","version":null,"tagName":"h3"},{"title":"insertBefore​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#insertBefore","content":"&lt;/&gt; Scheduler:insertBefore( pipeline: Pipeline, before: Phase | Pipeline ) → Scheduler Initializes the Pipeline and it's Phases within the Scheduler, ordering the Pipeline explicitly by setting the before Phase/Pipeline as a dependency.  ","version":null,"tagName":"h3"},{"title":"addSystems​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addSystems","content":"&lt;/&gt; Scheduler:addSystems( systems: System, phase: Phase? ) → () Adds the System to the Scheduler, scheduling it to be ran implicitly within the provided Phase or on the default Main phase.  ","version":null,"tagName":"h3"},{"title":"addSystems​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addSystems","content":"&lt;/&gt; Scheduler:addSystems( systems: {System}, phase: Phase? ) → () Adds the Systems to the Scheduler, scheduling them to be ran implicitly within the provided Phase or on the default Main phase.  ","version":null,"tagName":"h3"},{"title":"editSystem​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#editSystem","content":"&lt;/&gt; Scheduler:editSystem( system: System, newPhase: Phase ) → () Changes the Phase that this system is scheduled on.  ","version":null,"tagName":"h3"},{"title":"removeSystem​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#removeSystem","content":"&lt;/&gt; Scheduler:removeSystem(system: System) → () Removes the System from the Scheduler.  ","version":null,"tagName":"h3"},{"title":"replaceSystem​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#replaceSystem","content":"&lt;/&gt; Scheduler:replaceSystem( old: System, new: System ) → () Replaces the System with a new System.  ","version":null,"tagName":"h3"},{"title":"addRunCondition​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addRunCondition","content":"&lt;/&gt; Scheduler:addRunCondition( system: System, fn: (U...) → boolean ) → () Adds a Run Condition which the Scheduler will check before this System is ran.  ","version":null,"tagName":"h3"},{"title":"addRunCondition​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addRunCondition","content":"&lt;/&gt; Scheduler:addRunCondition( phase: Phase, fn: (U...) → boolean ) → () Adds a Run Condition which the Scheduler will check before any Systems within this Phase are ran.  ","version":null,"tagName":"h3"},{"title":"addRunCondition​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#addRunCondition","content":"&lt;/&gt; Scheduler:addRunCondition( pipeline: Pipeline, fn: (U...) → boolean ) → () Adds a Run Condition which the Scheduler will check before any Systems within any Phases apart of this Pipeline are ran.\\  ","version":null,"tagName":"h3"},{"title":"cleanup​","type":1,"pageTitle":"Scheduler","url":"/planck/api/Scheduler#cleanup","content":"&lt;/&gt; Scheduler:cleanup() → () Disconnects all events, closes all threads, and performs other cleanup work. DANGER Only use this if you intend to not use the associated Scheduler anymore. It will not work as intended. You should dereference the scheduler object so that it may be garbage collected. WARNING If you're creating a &quot;throwaway&quot; scheduler, you should not add plugins like Jabby or the Matter Debugger to it. These plugins are unable to properly be cleaned up, use them with caution. ","version":null,"tagName":"h3"},{"title":"Systems","type":0,"sectionRef":"#","url":"/planck/docs/design/systems","content":"","keywords":"","version":"Next"},{"title":"Single Responsibility​","type":1,"pageTitle":"Systems","url":"/planck/docs/design/systems#single-responsibility","content":" You should design your systems to have a single responsibility. A system should not do a lot of things, you should try and split up your systems into smaller systems when you can.  When you start out writing systems, you'll probably find yourself writing large systems that do many things. You can always go back and split up your systems afterwards.  ","version":"Next","tagName":"h2"},{"title":"Self Contained​","type":1,"pageTitle":"Systems","url":"/planck/docs/design/systems#self-contained","content":" Systems should also be self-contained, with isolated behavior. They should be designed to not depend on other systems. If we remove a system from our game, it should only remove the behavior declared in that system.  ","version":"Next","tagName":"h2"},{"title":"Aim for Generic, Reusable Systems​","type":1,"pageTitle":"Systems","url":"/planck/docs/design/systems#aim-for-generic-reusable-systems","content":" It's commonly said that using an ECS helps to create reusable code. This is true! Especially if you aim for single-responsibility systems and design them to be generic.  ","version":"Next","tagName":"h2"},{"title":"Application of these Principles​","type":1,"pageTitle":"Systems","url":"/planck/docs/design/systems#application-of-these-principles","content":" Let's make a system first, and apply these principles after.  local world = require(&quot;@shared/world&quot;) local scheduler = require(&quot;@shared/scheduler&quot;) local interval = require(&quot;@shared/interval&quot;) local throttle = interval(10) local Enemy = world:component() local Health = world:component() local Position = world:component() local Velocity = world:component() local function handleEnemies() -- Spawn enemies every 10 seconds if throttle() then local entity = world:entity() world:add(entity, Enemy) world:set(entity, Health, 100) world:set(entity, Position, Vector3.zero) world:set(entity, Velocity, Vector3.new(1, 0, 1)) end -- Move enemies every frame for entity, position, velocity in world:query(Position, Velocity):with(Enemy):iter() do local deltaTime = scheduler:getDeltaTime() world:set(entity, Position, position * deltaTime * velocity) end -- Despawn enemies with 0 health for entity, health in world:query(Health):with(Enemy):iter() if health == 0 then world:delete(entity) end end end   This system handles our enemies in our game, it has 3 distinct responsibilities: spawning enemies, moving enemies, and despawning enemies.  This system will get larger as we add more logic for our enemies, such as reconciling the position to an actual model, adding cases where enemies may lose health, and other mechanics onto our enemies.  We should split this system up into multiple, single responsibility systems.  local world = require(&quot;@shared/world&quot;) local interval = require(&quot;@shared/interval&quot;) local throttle = interval(10) local Enemy = world:component() local Health = world:component() local Position = world:component() local Velocity = world:component() local function spawnEnemies() -- Spawn enemies every 10 seconds if throttle() then local entity = world:entity() world:add(entity, Enemy) world:set(entity, Health, 100) world:set(entity, Position, Vector3.zero) world:set(entity, Velocity, Vector3.new(1, 0, 1)) end end   local world = require(&quot;@shared/world&quot;) local scheduler = require(&quot;@shared/scheduler&quot;) local Enemy = world:component() local Position = world:component() local Velocity = world:component() local function moveEnemies() -- Move enemies every frame for entity, position, velocity in world:query(Position, Velocity):with(Enemy):iter() do local deltaTime = scheduler:getDeltaTime() world:set(entity, Position, position * deltaTime * velocity) end end   local world = require(&quot;@shared/world&quot;) local Enemy = world:component() local Health = world:component() local function despawnEnemies() -- Despawn enemies with 0 health for entity, health in world:query(Health):with(Enemy):iter() if health == 0 then world:delete(entity) end end end   When designing systems, we should also think about reusability: how can you reuse a system in other parts of your game?  Well, we might want to move other models besides just Enemies. We can redesign our moveEnemies system to be generic.  local world = require(&quot;@shared/world&quot;) local scheduler = require(&quot;@shared/scheduler&quot;) local Enemy = world:component() local Position = world:component() local Velocity = world:component() local function moveModels() -- Move models every frame for entity, position, velocity in world:query(Position, Velocity):iter() do local deltaTime = scheduler:getDeltaTime() world:set(entity, Position, position * deltaTime * velocity) end end   ","version":"Next","tagName":"h2"},{"title":"What's Next?​","type":1,"pageTitle":"Systems","url":"/planck/docs/design/systems#whats-next","content":" Now that we know how to design Systems, we should learn more about Phase and Pipelines. ","version":"Next","tagName":"h2"},{"title":"Conditions","type":0,"sectionRef":"#","url":"/planck/docs/design/conditions","content":"","keywords":"","version":"Next"},{"title":"Run Conditions​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#run-conditions","content":" In Planck, we can assign Run Conditions to Systems, Phases, and Pipelines. Run Conditions are very simple, they are just functions that return true or false.  We can set a Run Condition on a System/Phase/Pipeline like so,  local function condition(world) if someCondition then return true else return false end end local scheduler = Scheduler.new(world) :addRunCondition(systemA, condition) :addRunCondition(somePhase, condition) :addRunCondition(somePipeline, condition)   ","version":"Next","tagName":"h2"},{"title":"Common Conditions​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#common-conditions","content":" Planck provides several built-in conditions for you to use as Run Conditions.  tip Some conditions, like onEvent have secondary purposes. You can use conditions themselves in systems, and conditions like onEvent will also create a collectEvents function which you can use to handle events inside of your systems.  ","version":"Next","tagName":"h2"},{"title":"Time Passed (Throttle)​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#time-passed-throttle","content":" Sometimes, we only want our systems to run on specific intervals. We can use the timePassed condition:  local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local timePassed = Planck.timePassed local scheduler = Scheduler.new(world) :addRunCondition(systemA, timePassed(10)) -- Run every 10 seconds   It's important to note that systemA will still be ran onRunService.Heartbeat. Our time will tick up until it reaches the given interval when the event fires again.  ","version":"Next","tagName":"h3"},{"title":"Run Once​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#run-once","content":" In Planck, we have Startup Phases built-in. You might want to recreate something akin to these if you're not using the built-in Phases.  local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local runOnce = Planck.runOnce local scheduler = Scheduler.new(world) :addRunCondition(systemA, runOnce()) -- Run only once   ","version":"Next","tagName":"h3"},{"title":"On Event​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#on-event","content":" We might want to run a system only when there are any new events since last frame.  local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local onEvent = Planck.onEvent local scheduler = Scheduler.new(world) -- Run out system only when there is a new Player :addRunCondition(systemA, onEvent(Players.PlayerAdded))   It is important to note that we don't actually collect the events using this condition. You will have to do that yourself.  local Players = game:GetService(&quot;Players&quot;) local Planck = require(&quot;@packages/Planck&quot;) local onEvent = Planck.onEvent local hasNewEvent, collectEvents = onEvent(Players.PlayerAdded) local function systemA() for i, player in collectEvents() do -- Do something end end return { system = systemA, runConditions = { hasNewEvent } }   Cleaning Up Events If you would like to cleanup the event connection that the onEvent condition uses, you can get the disconnect function like so. local Planck = require(&quot;@packages/Planck&quot;) local onEvent = Planck.onEvent local hasNewEvent, collectEvents, getDisconnectFn = onEvent(Players.PlayerAdded) local disconnect = getDisconnectFn() disconnect() -- Event is no longer connected If you use scheduler:removeSystem() to remove a system, all of it's conditions will be cleaned up with it, so long as the condition is not being used for any other system, phase, or pipeline.  Defining Events​  Planck.onEvent supports many different ways of defining events. Some provide full typechecking, while others don't.  Types TypecheckedRBXScriptSignal\tPlanck.onEvent(Players.PlayerAdded)\t✓ Instance, RBXScriptSignal\tPlanck.onEvent(Players, Players.PlayerAdded)\t✓ Instance, string\tPlanck.onEvent(Players, &quot;PlayerAdded&quot;)\t✕ SignalLike\tPlanck.onEvent(mySignal)\t✓ table, string\tPlanck.onEvent(t, &quot;connect&quot;)\t✕ table, method\tPlanck.onEvent(t, t.connect)\t✓ function\tPlanck.onEvent(connect)\t✓  ","version":"Next","tagName":"h3"},{"title":"Not​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#not","content":" This is a really simple condition, it just inverses the condition passed.  local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local onEvent = Planck.onEvent local isNot = Planck.isNot local scheduler = Scheduler.new(world) -- Run our system only when there is a new Player :addRunCondition(systemA, isNot(onEvent(Players.PlayerAdded)))   ","version":"Next","tagName":"h3"},{"title":"Ideas for Conditions​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#ideas-for-conditions","content":" ","version":"Next","tagName":"h2"},{"title":"Player Alive​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#player-alive","content":" In Roblox, we typically have a Player with a Humanoid. It might make sense to only run some systems when the Player is alive.  Here's a write up for what that might look like for a client system,  -- Player singleton local LocalPlayer = world:component() world:set(LocalPlayer, LocalPlayer) world:set(LocalPlayer, Health, 100) local function playerAlive() return function(world) local health = world:get(LocalPlayer, Health) if health &gt; 0 then return true else return false end end end local scheduler = Scheduler.new(world) -- Run the system only when the Player is alive :addRunCondition(systemA, playerAlive())   This helps us to avoid unnecessarily running systems that only have behavior when the Player is alive.  ","version":"Next","tagName":"h3"},{"title":"Run Conditions Are Not Dependencies​","type":1,"pageTitle":"Conditions","url":"/planck/docs/design/conditions#run-conditions-are-not-dependencies","content":" Your systems should not depend on conditions. In the context of your system, it should not matter whether a Run Condition is true or false, the system should work.  The purpose of Run Conditions are to minimize the amount of systems that are running during a frame, by cutting out systems which do not need to run in a given moment. ","version":"Next","tagName":"h2"},{"title":"RunService Phases","type":0,"sectionRef":"#","url":"/planck/docs/plugins/runservice","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"RunService Phases","url":"/planck/docs/plugins/runservice#installation","content":" wally.toml [dependencies] PlanckRunService = &quot;yetanotherclown/planck-runservice@0.2.0-rc.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Setup​","type":1,"pageTitle":"RunService Phases","url":"/planck/docs/plugins/runservice#setup","content":" First, we need to create the scheduler, and add the Plugin to it.  src/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local runServicePlugin = PlanckRunService.new() local scheduler = scheduler.new(world) :addPlugin(runServicePlugin) return scheduler   ","version":"Next","tagName":"h3"},{"title":"Pipelines​","type":1,"pageTitle":"RunService Phases","url":"/planck/docs/plugins/runservice#pipelines","content":" Each RunService Event is now it's own Pipeline,  PreRenderPreAnimationPreSimulationPostSimulationHeartbeat  tip You might be more familiar with the old names for some of these events. PreRender is equivalent to RenderSteppedPreSimulation is equivalent to Stepped  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Pipelines = PlanckRunService.Pipelines local PreRender = Pipelines.PreRender local PreAnimation = Pipelines.PreAnimation local PreSimulation = Pipelines.PreSimulation local PostSimulation = Pipelines.PostSimulation local Heartbeat = Pipelines.Heartbeat   ","version":"Next","tagName":"h3"},{"title":"Phases​","type":1,"pageTitle":"RunService Phases","url":"/planck/docs/plugins/runservice#phases","content":" And it's own Phase, with the exception of Heartbeat which has many Phases.  Event\tPhasePreRender\tPreRender PreAnimation\tPreAnimation PreSimulation\tPreSimulation PostSimulation\tPostSimulation Heartbeat\tUpdate  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Phases = PlanckRunService.Phases local PreRender = Phases.PreRender local PreAnimation = Phases.PreAnimation local PreSimulation = Phases.PreSimulation local PostSimulation = Phases.PostSimulation local Update = Phases.Update   ","version":"Next","tagName":"h3"},{"title":"More Update Phases​","type":1,"pageTitle":"RunService Phases","url":"/planck/docs/plugins/runservice#more-update-phases","content":" RunService.Heartbeat isn't just a single Phase, instead its composed of many Phases. This is because the Update Phases are where most of your game's logic will run on, so we believe it's important that you can express the order of execution easily right out of the box.  FirstPreUpdateUpdatePostUpdateLast  local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local Phases = PlanckRunService.Phases local First = Phases.First local PreUpdate = Phases.PreUpdate local Update = Phases.Update local PostUpdate = Phases.PostUpdate local Last = Phases.Last  ","version":"Next","tagName":"h3"},{"title":"The Scheduler","type":0,"sectionRef":"#","url":"/planck/docs/getting_started/scheduler","content":"","keywords":"","version":"Next"},{"title":"What's Next?​","type":1,"pageTitle":"The Scheduler","url":"/planck/docs/getting_started/scheduler#whats-next","content":" Let's learn how to make Systems and add then to our Scheduler now.  → Systems ","version":"Next","tagName":"h2"},{"title":"Glossary","type":0,"sectionRef":"#","url":"/planck/docs/intro","content":"Glossary Here's a quick navigation of Planck's Docs. Getting Started​ IntroductionThe SchedulerSystemsPhasesOrder of Execution Designing with Planck​ IntroductionSystemsPhases &amp; PipelinesConditions Setup Guides​ MatterJecs Plugins​ PluginsJabbyMatter HooksMatter DebuggerRunService Phases API​ SchedulerPipelinePhase","keywords":"","version":"Next"},{"title":"Systems","type":0,"sectionRef":"#","url":"/planck/docs/getting_started/systems","content":"","keywords":"","version":"Next"},{"title":"System Tables​","type":1,"pageTitle":"Systems","url":"/planck/docs/getting_started/systems#system-tables","content":" Another way you can define a System is with a SystemTable.  SystemTables contain not only the function but can also contain a Phase, Name, and Run Condition for Systems.  Field\tType\tname\tstring\tOptional system\tfunction\tRequired phase\tPhase\tOptional runConditions\t{ (...any) -&gt; boolean }\tOptional  The Name is used for debugging and used in tooling such as Jabby to help you identify systems, this is automatically inferred from the function name, so it's completely optional.  Don't worry about what a Phase or Run Condition is for now, we will explain these later.  systemA.luau local function systemA(world, state) -- ... end local function condition(world, state) if someCondition then return true else return false end end return { name = &quot;systemA&quot;, system = systemA, phase = Planck.Phase.PreUpdate, runConditions = { condition } }   And then we can add this the same way as the first example,  scheduler.luau -- ... local systemA = require(&quot;@shared/systems/systemA&quot;) local scheduler = Scheduler.new(world, state) :addSystem(systemA)   ","version":"Next","tagName":"h3"},{"title":"System Sets​","type":1,"pageTitle":"Systems","url":"/planck/docs/getting_started/systems#system-sets","content":" You can also create a set, or rather an array of Systems. These can either be functions or SystemTables. You can even mix the two in a System Set.  -- ... local systemA = require(&quot;@shared/systems/systemA&quot;) local systemB = require(&quot;@shared/systems/systemB&quot;) local systemSet = { systemA, systemB } local scheduler = Scheduler.new(world, state) :addSystems(systemSet)   This allows us to bulk add systems to the Scheduler. When we learn about Phases, this will also allow us to bulk set what phase these systems run on.  ","version":"Next","tagName":"h3"},{"title":"What's Next?​","type":1,"pageTitle":"Systems","url":"/planck/docs/getting_started/systems#whats-next","content":" Now that we have systems, we should learn how to properly manage their order of execution. This is where Phases come in.  → Phases ","version":"Next","tagName":"h2"},{"title":"Plugins","type":0,"sectionRef":"#","url":"/planck/docs/plugins/","content":"","keywords":"","version":"Next"},{"title":"Provided Plugins​","type":1,"pageTitle":"Plugins","url":"/planck/docs/plugins/#provided-plugins","content":" ","version":"Next","tagName":"h2"},{"title":"Matter Hooks​","type":1,"pageTitle":"Plugins","url":"/planck/docs/plugins/#matter-hooks","content":" The Matter Hooks plugin provides a way to use the Matter topoRuntime to use any hook made for Matter. This can be used with any ECS library.  tip The Matter Hooks Plugin can be used with any ECS library, like Jecs or ECR. If you want to still use hooks when using Matter, you must still add this Plugin to the Scheduler for hooks to work.  See the Matter Hooks page.  ","version":"Next","tagName":"h3"},{"title":"Matter Debugger​","type":1,"pageTitle":"Plugins","url":"/planck/docs/plugins/#matter-debugger","content":" Matter provides a built-in Debugger, this plugin adds support for Planck.  See the Matter Debugger page.  ","version":"Next","tagName":"h3"},{"title":"Jabby​","type":1,"pageTitle":"Plugins","url":"/planck/docs/plugins/#jabby","content":" Jabby is a Debugger for Jecs by Ukendio. This Plugin handles all setup to add the Planck Scheduler to Jabby.  See the Jabby page.  ","version":"Next","tagName":"h3"},{"title":"Creating Plugins​","type":1,"pageTitle":"Plugins","url":"/planck/docs/plugins/#creating-plugins","content":" danger The API behind Plugins is currently unstable. The Plugins API will continue to be undocumented until it is stable. If you want to create a Plugin, see the two provided Plugin's source code, and be warned. ","version":"Next","tagName":"h2"},{"title":"Jabby","type":0,"sectionRef":"#","url":"/planck/docs/plugins/jabby","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Jabby","url":"/planck/docs/plugins/jabby#installation","content":" wally.toml [dependencies] PlanckJabby = &quot;yetanotherclown/planck-jabby@0.2.0-rc.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Setup and Use​","type":1,"pageTitle":"Jabby","url":"/planck/docs/plugins/jabby#setup-and-use","content":" First, we need to create the scheduler, and add the Jabby Plugin to it.  src/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local PlanckJabby = require(&quot;@packages/PlanckJabby&quot;) local jabbyPlugin = PlanckJabby.new() local scheduler = scheduler.new(world) :addPlugin(jabbyPlugin) return scheduler   This only adds the Scheduler to Jabby, you'll have to add the World and other setup yourself. ","version":"Next","tagName":"h3"},{"title":"Matter Debugger","type":0,"sectionRef":"#","url":"/planck/docs/plugins/matter_debugger","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Matter Debugger","url":"/planck/docs/plugins/matter_debugger#installation","content":" wally.toml [dependencies] DebuggerPlugin = &quot;yetanotherclown/planck-matter-debugger@0.2.0-rc.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Setup and Use​","type":1,"pageTitle":"Matter Debugger","url":"/planck/docs/plugins/matter_debugger#setup-and-use","content":" First, we need to create the scheduler, and add the Debugger Plugin to it.  src/shared/scheduler.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Matter = require(&quot;@packages/Matter&quot;) local Plasma = require(&quot;@packages/Plasma&quot;) local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local DebuggerPlugin = require(&quot;@packages/DebuggerPlugin&quot;) local debuggerPlugin = DebuggerPlugin.new({ world }) local debugger = Matter.Debugger.new(Plasma) local widgets = debugger:getWidgets() local scheduler = scheduler.new(world, widgets) :addPlugin(debuggerPlugin) debugger:autoInitialize(debuggerPlugin:getLoop()) return scheduler   Next, you can add your systems to the scheduler and use your widgets and the debugger to inspect your code.  See the Debugger Guide on the Matter Documentation site for more information about the Debugger. ","version":"Next","tagName":"h3"},{"title":"Matter Hooks","type":0,"sectionRef":"#","url":"/planck/docs/plugins/matter_hooks","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Matter Hooks","url":"/planck/docs/plugins/matter_hooks#installation","content":" wally.toml [dependencies] MatterHooks = &quot;yetanotherclown/planck-matter-hooks@0.2.0-rc.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Setup and Use​","type":1,"pageTitle":"Matter Hooks","url":"/planck/docs/plugins/matter_hooks#setup-and-use","content":" First, let's make a system and use our hooks.  Hooks are exported from the Matter Hooks plugin, so we can use them within our systems like so:  src/shared/systems/systemA.luau local MatterHooks = require(&quot;@packages/MatterHooks&quot;) local useDeltaTime = MatterHooks.useDeltaTime local useEvent = MatterHooks.useEvent local useThrottle = MatterHooks.useThrottle function systemA() if useThrottle(5) then print(&quot;Throttled for 5 seconds&quot;) end end return systemA   Then we need to create the scheduler, and add the Hooks Plugin to it.  src/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local MatterHooks = require(&quot;@packages/MatterHooks&quot;) local hooksPlugin = MatterHooks.new() local scheduler = scheduler.new() :addPlugin(hooksPlugin) return scheduler   And finally, add the system to your scheduler.  src/shared/startup.luau local scheduler = require(&quot;@shared/scheduler&quot;) local systemA = require(&quot;@shared/systems/systemA&quot;) return function() scheduler :addSystem(systemA) end   ","version":"Next","tagName":"h3"},{"title":"API​","type":1,"pageTitle":"Matter Hooks","url":"/planck/docs/plugins/matter_hooks#api","content":" API can be found on the Matter documentation site, click the following links to be redirected.  Scheduler.logScheduler.useDeltaTimeScheduler.useEventScheduler.useHookStateScheduler.useThrottle  ","version":"Next","tagName":"h3"},{"title":"Using with Matter​","type":1,"pageTitle":"Matter Hooks","url":"/planck/docs/plugins/matter_hooks#using-with-matter","content":" To use Matter's Hooks in Matter, you still need to use this Plugin.  By default, the Plugin will look for the official Matter library in ReplicatedStorage/Packages/_Index. This should work if you're installing from Wally. If you're not, you can pass in a reference to the Matter library in the Plugin constructor.  src/shared/scheduler.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local MatterHooks = require(&quot;@packages/MatterHooks&quot;) local hooksPlugin = MatterHooks.new(ReplicatedStorage.Matter) local scheduler = scheduler.new() :addPlugin(hooksPlugin) return scheduler  ","version":"Next","tagName":"h3"},{"title":"Jecs","type":0,"sectionRef":"#","url":"/planck/docs/setup_guides/jecs","content":"","keywords":"","version":"Next"},{"title":"Creating the World​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#creating-the-world","content":" First, we'll create a module called world.luau where we create and export our Jecs World.  ReplicatedStorage/shared/world.luau local Jecs = require(&quot;@packages/Jecs&quot;) local World = Jecs.World local world = World.new() return world   ","version":"Next","tagName":"h3"},{"title":"Creating the Scheduler​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#creating-the-scheduler","content":" Next, we'll create a module called scheduler.luau where we create and export our scheduler.  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local scheduler = Scheduler.new() return scheduler   Then lets pass the world to our scheduler  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local scheduler = Scheduler.new(world) return scheduler   And then let's add the Jabby and RunService Plugins  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local PlanckJabby = require(&quot;@packages/PlanckJabby&quot;) local jabbyPlugin = PlanckJabby.new() local PlanckRunService = require(&quot;@packages/PlanckRunService&quot;) local runServicePlugin = PlanckRunService.Plugin.new() local scheduler = Scheduler.new(world) :addPlugin(jabbyPlugin) :addPlugin(runServicePlugin) return scheduler   This next part is up to preference, if you would like to use the Matter topoRuntime to run Matter Hooks with Jecs you can follow add the Matter Hooks Plugin too.  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local PlanckJabby = require(&quot;@packages/PlanckJabby&quot;) local jabbyPlugin = PlanckJabby.new() local MatterHooks = require(&quot;@packages/MatterHooks&quot;) local hooksPlugin = MatterHooks.new() local scheduler = Scheduler.new(world) :addPlugin(jabbyPlugin) :addPlugin(hooksPlugin) return scheduler   ","version":"Next","tagName":"h3"},{"title":"Making Components​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#making-components","content":" We'll store our Jecs components in a components.luau module.  ReplicatedStorage/shared/components.luau local world = require(&quot;@shared/world&quot;) return { Name = world:component(), Eats = world:component(), Apples = world:component(), Oranges = world:component(), }   ","version":"Next","tagName":"h3"},{"title":"Creating Your First Systems​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#creating-your-first-systems","content":" Let's create a basic system with Planck + Jecs  This system will setup our initial entities, hence it running on the Startup phase.  ReplicatedStorage/shared/systems/systemA.luau local Jecs = require(&quot;@packages/Jecs&quot;) local pair = Jecs.pair local Planck = require(&quot;@packages/Planck&quot;) local Phase = Planck.Phase local components = require(&quot;@shared/components&quot;) local Name = components.Name local Eats = components.Eats local Apples = components.Apples local Oranges = components.Oranges local function systemA(world) world:set(Apples, Name, &quot;apples&quot;) world:set(Oranges, Name, &quot;oranges&quot;) local bob = world:entity() world:set(bob, pair(Eats, Apples), 10) world:set(bob, pair(Eats, Oranges), 5) world:set(bob, Name, &quot;bob&quot;) local alice = world:entity() world:set(alice, pair(Eats, Apples), 4) world:set(alice, Name, &quot;alice&quot;) end return { system = systemA phase = Phase.Startup }   This next system will query each frame and print out which entity eats what.  ReplicatedStorage/shared/systems/systemB.luau local Jecs = require(&quot;@packages/Jecs&quot;) local pair = Jecs.pair local Wildcard = Jecs.Wildcard local components = require(&quot;@shared/components&quot;) local Name = components.Name local Eats = components.Eats local function systemB(world) for id, amount in world:query(pair(Eats, Wildcard)) do local food = world:target(id, Eats) local foodName = world:get(food, Name) local entityName = world:get(id, Name) print(string.format(&quot;%s eats %d %s&quot;, entityName, amount, foodName)) end end return systemB   Notice how you can define systems as either a function or a table!  While you can set the phase directly in Scheduler:addSystem(fn, phase), it may be convenient to use a System Table instead.  note Notice how we pass world into our system functions instead of requiring the module we made. We do this to keep systems pure, we avoid external dependencies by passing our dependencies as function parameters. This makes our systems more testable and reusable.  ","version":"Next","tagName":"h3"},{"title":"Your Startup Function​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#your-startup-function","content":" Your Startup function is where you first require the world and scheduler modules, where you would add your systems to the scheduler, and where we will setup Jabby.  ReplicatedStorage/shared/startup.luau local Jabby = require(&quot;@packages/Jabby&quot;) local scheduler = require(&quot;@shared/scheduler&quot;) local world = require(&quot;@shared/world&quot;) return function(systems) if #systems ~= 0 then scheduler:addSystems(systems) -- Assuming you're using SystemTables! end if RunService:IsClient() then local client = Jabby.obtain_client() local function createWidget(_, state: Enum.UserInputState) if state ~= Enum.UserInputState.Begin then return end client.spawn_app(client.apps.home, nil) end ContextActionService:BindAction(&quot;Open Jabby&quot;, createWidget, false, Enum.KeyCode.F4) end Jabby.register({ applet = Jabby.applets.world, name = &quot;Jecs World&quot;, configuration = { world = world } }) end   ","version":"Next","tagName":"h3"},{"title":"Server / Client Scripts​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#server--client-scripts","content":" On the client, we'll add the shared and client systems.  ReplicatedStorage/client/client.client.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local startup = require(&quot;@shared/startup&quot;) local systems = {} local function addSystems(folder) for _, system in folder:GetChildren() do if not system:IsA(&quot;ModuleScript&quot;) then continue end table.insert(systems, require(system)) end end addSystems(ReplicatedStorage.shared.systems) addSystems(ReplicatedStorage.client.systems) startup(systems)   On the server, we'll instead add the server systems.  ServerScriptService/server/server.server.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local startup = require(&quot;@shared/startup&quot;) local systems = {} local function addSystems(folder) for _, system in folder:GetChildren() do if not system:IsA(&quot;ModuleScript&quot;) then continue end table.insert(systems, require(system)) end end addSystems(ReplicatedStorage.shared.systems) addSystems(ReplicatedStorage.server.systems) startup(systems)   ","version":"Next","tagName":"h3"},{"title":"Credits​","type":1,"pageTitle":"Jecs","url":"/planck/docs/setup_guides/jecs#credits","content":" This setup guide was heavily influenced by official Jecs examples and documentation. ","version":"Next","tagName":"h3"},{"title":"Matter","type":0,"sectionRef":"#","url":"/planck/docs/setup_guides/matter","content":"","keywords":"","version":"Next"},{"title":"Creating the World​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#creating-the-world","content":" First, we'll create a module called world.luau where we create and export our Matter World.  ReplicatedStorage/shared/world.luau local Matter = require(&quot;@packages/Matter&quot;) local World = Matter.World local world = World.new() return world   ","version":"Next","tagName":"h3"},{"title":"Creating the Scheduler​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#creating-the-scheduler","content":" Next, we'll create a module called scheduler.luau where we create and export our scheduler.  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local scheduler = scheduler.new() return scheduler   Then lets pass the world to our scheduler  ReplicatedStorage/shared/scheduler.luau local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local scheduler = scheduler.new(world) return scheduler   And then let's add our Hooks Plugin (we will add the Debugger plugin later)  ReplicatedStorage/shared/scheduler.luau local Matter = require(&quot;@packages/Matter&quot;) local Plasma = require(&quot;@packages/Plasma&quot;) local Planck = require(&quot;@packages/Planck&quot;) local Scheduler = Planck.Scheduler local world = require(&quot;@shared/world&quot;) local DebuggerPlugin = require(&quot;@packages/DebuggerPlugin&quot;) local debuggerPlugin = DebuggerPlugin.new({ world }) local debugger = Matter.Debugger.new(Plasma) local widgets = debugger:getWidgets() local HooksPlugin = require(&quot;@packages/HooksPlugin&quot;) local hooksPlugin = HooksPlugin.new() local scheduler = scheduler.new(world, widgets) :addPlugin(hooksPlugin) :addPlugin(debuggerPlugin) debugger:autoInitialize(debuggerPlugin:getLoop()) return scheduler   ","version":"Next","tagName":"h3"},{"title":"Making Components​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#making-components","content":" We'll store our Matter components in a components.luau module.  ReplicatedStorage/shared/components.luau local Matter = require(&quot;@packages/Matter&quot;) return { MyComponent = Matter.component(&quot;myComponent&quot;), }   ","version":"Next","tagName":"h3"},{"title":"Creating Your First Systems​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#creating-your-first-systems","content":" Let's create a basic system with Planck + Matter  In Startup systems, we can perform startup logic such as setting up our initial entities, hence it running on the Startup phase.  ReplicatedStorage/shared/systems/systemA.luau local Matter = require(&quot;@packages/Matter&quot;) local Planck = require(&quot;@packages/Planck&quot;) local Phase = Planck.Phase local components = require(&quot;@shared/components&quot;) local function systemA(world) -- Runs only once before all other Phases end return { system = systemA phase = Phase.Startup }   To create a normal system, we do not need to provide a Phase.  ReplicatedStorage/shared/systems/systemB.luau local function systemB(world) -- ... end return systemB   Notice how you can define systems as either a function or a table!  While you can set the phase directly in Scheduler:addSystem(fn, phase), it may be convenient to use a System Table instead.  note Notice how we pass world into our system functions instead of requiring the module we made. We do this to keep systems pure, we avoid external dependencies by passing our dependencies as function parameters. This makes our systems more testable and reusable.  ","version":"Next","tagName":"h3"},{"title":"Your Startup Function​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#your-startup-function","content":" Your Startup function is where you first require the world and scheduler modules, where you would add your systems to the scheduler, and where we will setup our Debugger.  ReplicatedStorage/shared/startup.luau local scheduler = require(&quot;@shared/scheduler&quot;) local world = require(&quot;@shared/world&quot;) return function(systems) if #systems ~= 0 then scheduler:addSystems(systems) -- Assuming you're using SystemTables! end end   ","version":"Next","tagName":"h3"},{"title":"Server / Client Scripts​","type":1,"pageTitle":"Matter","url":"/planck/docs/setup_guides/matter#server--client-scripts","content":" On the client, we'll add the shared and client systems.  ReplicatedStorage/client/client.client.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local startup = require(&quot;@shared/startup&quot;) local systems = {} local function addSystems(folder) for _, system in folder:GetChildren() do if not system:IsA(&quot;ModuleScript&quot;) then continue end table.insert(systems, require(system)) end end addSystems(ReplicatedStorage.shared.systems) addSystems(ReplicatedStorage.client.systems) startup(systems)   On the server, we'll instead add the server systems.  ServerScriptService/server/server.server.luau local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local startup = require(&quot;@shared/startup&quot;) local systems = {} local function addSystems(folder) for _, system in folder:GetChildren() do if not system:IsA(&quot;ModuleScript&quot;) then continue end table.insert(systems, require(system)) end end addSystems(ReplicatedStorage.shared.systems) addSystems(ReplicatedStorage.server.systems) startup(systems)  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}