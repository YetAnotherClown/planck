"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[758],{80670:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>d,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"getting_started/order","title":"Order of Execution","description":"The basics on ordering","source":"@site/docs/getting_started/order.md","sourceDirName":"getting_started","slug":"/getting_started/order","permalink":"/planck/docs/getting_started/order","draft":false,"unlisted":false,"editUrl":"https://github.com/YetAnotherClown/planck/edit/main/docs/getting_started/order.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Order of Execution","description":"The basics on ordering","sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Phases","permalink":"/planck/docs/getting_started/phases"},"next":{"title":"Designing with Planck","permalink":"/planck/docs/design/"}}');var r=s(74848),t=s(28453);const d={title:"Order of Execution",description:"The basics on ordering",sidebar_position:5},l="Order of Execution",o={},h=[{value:"The Algorithm",id:"the-algorithm",level:2},{value:"Key Terms",id:"key-terms",level:3},{value:"Steps",id:"steps",level:3},{value:"Pipelines and Phases",id:"pipelines-and-phases",level:2},{value:"Built-in",id:"built-in",level:3},{value:"Custom",id:"custom",level:3},{value:"With Events",id:"with-events",level:3},{value:"Whats Next?",id:"whats-next",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"order-of-execution",children:"Order of Execution"})}),"\n",(0,r.jsx)(n.p,{children:"When using Planck, it is important to understand how your Pipelines, Phases,\r\nand Systems will be ordered."}),"\n",(0,r.jsx)(n.p,{children:"The order of execution is determined by two key things:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Order of Insertion"}),"\n",(0,r.jsx)(n.li,{children:"Phases/Pipelines dependents/dependencies"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Planck uses these two things within an algorithm to order your Pipelines,\r\nPhases, and Systems each frame."}),"\n",(0,r.jsx)(n.h2,{id:"the-algorithm",children:"The Algorithm"}),"\n",(0,r.jsx)(n.p,{children:"Planck uses Kahn's algorithm to determine the order your Pipelines and\r\nPhases will run in. Whereas systems are just ordered by the order of\r\ninsertion into the Scheduler."}),"\n",(0,r.jsx)(n.h3,{id:"key-terms",children:"Key Terms"}),"\n",(0,r.jsx)(n.p,{children:"It is important to understand the following terms while explaining how ordering works:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.em,{children:"dependency"})," is any Phase/Pipeline another Phase/Pipeline depends on."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.em,{children:"dependent"})," if the Phase/Pipeline that depends on another Phase/Pipeline."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This looks like, ",(0,r.jsx)(n.code,{children:"insertAfter(dependent, dependency)"})," or ",(0,r.jsx)(n.code,{children:"insertBefore(dependent, dependency)"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"steps",children:"Steps"}),"\n",(0,r.jsx)(n.p,{children:"And now to explain how the algorithm works, here are the steps it takes"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Start with the first Phase/Pipeline inserted"}),"\n",(0,r.jsx)(n.li,{children:"If this Phase/Pipeline has any dependency, skip it and move onto the next one."}),"\n",(0,r.jsx)(n.li,{children:"Add this Phase/Pipeline to the order"}),"\n",(0,r.jsx)(n.li,{children:"If this Phase/Pipeline has any dependents, repeat this process in order of insertion for each dependent Phase/Pipeline."}),"\n",(0,r.jsx)(n.li,{children:"Move onto the next Phase/Pipeline."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"pipelines-and-phases",children:"Pipelines and Phases"}),"\n",(0,r.jsx)(n.h3,{id:"built-in",children:"Built-in"}),"\n",(0,r.jsx)(n.p,{children:"It is important to note that all of the built-in Phases you see will run\r\nin the order they appear in the Documentation. Each of these Phases represent\r\na single sync point within a single frame of your game."}),"\n",(0,r.jsx)(n.p,{children:"PreRender -> PreAnimation -> PreSimulation -> PostSimulation -> UpdatePipeline"}),"\n",(0,r.jsx)(n.h3,{id:"custom",children:"Custom"}),"\n",(0,r.jsxs)(n.p,{children:["When using custom Pipelines or Phases, ",(0,r.jsx)(n.code,{children:"Scheduler:insert()"})," will order them\r\nby order of insertion. This is done by making the last added Phase/Pipeline a\r\ndependency of the latest Phase/Pipeline."]}),"\n",(0,r.jsx)(n.p,{children:"For example,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local scheduler = Scheduler.new()\r\n    :insert(phaseA)\r\n    :insert(phaseB)\r\n    :runAll()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"phaseA"})," will run before ",(0,r.jsx)(n.code,{children:"phaseB"})," when we do ",(0,r.jsx)(n.code,{children:"scheduler:runAll()"}),".\r\nIn this scenario, ",(0,r.jsx)(n.code,{children:"phaseA"})," is a dependency of ",(0,r.jsx)(n.code,{children:"phaseB"}),", where ",(0,r.jsx)(n.code,{children:"phaseA"}),"\r\nmust run before ",(0,r.jsx)(n.code,{children:"phaseB"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Systems don't have any dependencies, they are only ordered by insertion\r\nwithin a phase,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local scheduler = Scheduler.new()\r\n    :addSystem(systemA)\r\n    :addSystem(systemB)\r\n    :runAll()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So, ",(0,r.jsx)(n.code,{children:"systemA"})," runs before ",(0,r.jsx)(n.code,{children:"systemB"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["You can create dependencies for Phases/Pipelines explicitly too by using\r\n",(0,r.jsx)(n.code,{children:"Scheduler:insertAfter()"})," and ",(0,r.jsx)(n.code,{children:"Scheduler:insertBefore()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local scheduler = Scheduler.new()\r\n    :insert(phaseA)\r\n    :insertAfter(phaseB, phaseA)\r\n    :runAll()\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"phaseB"})," now depends on ",(0,r.jsx)(n.code,{children:"phaseA"}),", meaning it can't run until ",(0,r.jsx)(n.code,{children:"phaseA"})," runs."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Scheduler:insertBefore(phaseB, phaseA)"})," works similarly too, except ",(0,r.jsx)(n.code,{children:"phaseB"})," can only\r\nrun before ",(0,r.jsx)(n.code,{children:"phaseA"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"with-events",children:"With Events"}),"\n",(0,r.jsxs)(n.p,{children:["Phases and Pipelines are grouped together into Groups.\r\nEach Event is it's own group, and then we also have the ",(0,r.jsx)(n.code,{children:"Default"})," group."]}),"\n",(0,r.jsxs)(n.p,{children:["When using ",(0,r.jsx)(n.code,{children:"insertAfter()"})," or ",(0,r.jsx)(n.code,{children:"insertBefore()"}),", the dependent Phase/Pipeline\r\nwill inherit the event of it's dependency, joining that group.\r\nUsing ",(0,r.jsx)(n.code,{children:"insert()"})," will always add a Phase/Pipeline to the ",(0,r.jsx)(n.code,{children:"Default"})," group when\r\nno event is specified."]}),"\n",(0,r.jsx)(n.p,{children:"Phases/Pipelines in different groups are not ordered together, instead each\r\ngroup is isolated and their Phases/Pipelines will run in an order within the\r\ngroup."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:"local scheduler = Scheduler.new()\r\n    :insert(pipelineA, RunService.Heartbeat)\r\n    :insertAfter(pipelineB, RunService.PostSimulation)\r\n    :runAll()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This code will create two groups: ",(0,r.jsx)(n.code,{children:"Heartbeat"})," and ",(0,r.jsx)(n.code,{children:"PostSimulation"}),".\r\nWhen ",(0,r.jsx)(n.code,{children:"Scheduler:runAll()"})," runs, first it will process every Phase or Pipeline\r\non the ",(0,r.jsx)(n.code,{children:"Heartbeat"})," group. And then, it will process every Phase or Pipeline on the\r\n",(0,r.jsx)(n.code,{children:"PostSimulation"})," group."]}),"\n",(0,r.jsx)(n.h2,{id:"whats-next",children:"Whats Next?"}),"\n",(0,r.jsx)(n.p,{children:"You're ready to begin building a game with Planck!"}),"\n",(0,r.jsx)(n.p,{children:"Checkout the setup guides for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/planck/docs/setup_guides/matter",children:"Matter"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/planck/docs/setup_guides/jecs",children:"Jecs"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Already read those guides? Already have a game with Planck?\r\nLearn how to properly design Pipelines, Phases, and Systems."}),"\n",(0,r.jsxs)(n.p,{children:["\u2192 ",(0,r.jsx)(n.a,{href:"/planck/docs/design/",children:"The Order of Execution"})]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);