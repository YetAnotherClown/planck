"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[949],{77403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"design/conditions","title":"Conditions","description":"Designing with Conditions","source":"@site/docs/design/conditions.md","sourceDirName":"design","slug":"/design/conditions","permalink":"/planck/docs/design/conditions","draft":false,"unlisted":false,"editUrl":"https://github.com/YetAnotherClown/planck/edit/main/docs/design/conditions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Conditions","description":"Designing with Conditions","sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"Phases and Pipelines","permalink":"/planck/docs/design/phases-and-pipelines"},"next":{"title":"Matter","permalink":"/planck/docs/setup_guides/matter"}}');var s=t(74848),l=t(28453);const r={title:"Conditions",description:"Designing with Conditions",sidebar_position:4},o="Conditions",d={},c=[{value:"Run Conditions",id:"run-conditions",level:2},{value:"Common Conditions",id:"common-conditions",level:2},{value:"Time Passed (Throttle)",id:"time-passed-throttle",level:3},{value:"Run Once",id:"run-once",level:3},{value:"On Event",id:"on-event",level:3},{value:"Defining Events",id:"defining-events",level:4},{value:"Not",id:"not",level:3},{value:"Ideas for Conditions",id:"ideas-for-conditions",level:2},{value:"Player Alive",id:"player-alive",level:3},{value:"Run Conditions Are Not Dependencies",id:"run-conditions-are-not-dependencies",level:2}];function a(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"conditions",children:"Conditions"})}),"\n",(0,s.jsx)(n.p,{children:"During the execution of your game's code, not everything needs to be\r\nexecuted every frame. This is where conditions come in!"}),"\n",(0,s.jsx)(n.h2,{id:"run-conditions",children:"Run Conditions"}),"\n",(0,s.jsxs)(n.p,{children:["In Planck, we can assign ",(0,s.jsx)(n.em,{children:"Run Conditions"})," to Systems, Phases, and Pipelines.\r\nRun Conditions are very simple, they are just functions that return true or\r\nfalse."]}),"\n",(0,s.jsx)(n.p,{children:"We can set a Run Condition on a System/Phase/Pipeline like so,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"local function condition(world)\r\n    if someCondition then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    :addRunCondition(systemA, condition)\r\n    :addRunCondition(somePhase, condition)\r\n    :addRunCondition(somePipeline, condition)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-conditions",children:"Common Conditions"}),"\n",(0,s.jsx)(n.p,{children:"Planck provides several built-in conditions for you to use as\r\nRun Conditions."}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Some conditions, like ",(0,s.jsx)(n.code,{children:"onEvent"})," have secondary purposes."]}),(0,s.jsxs)(n.p,{children:["You can use conditions themselves in systems, and conditions\r\nlike ",(0,s.jsx)(n.code,{children:"onEvent"})," will also create a ",(0,s.jsx)(n.code,{children:"collectEvents"})," function which\r\nyou can use to handle events inside of your systems."]})]}),"\n",(0,s.jsx)(n.h3,{id:"time-passed-throttle",children:"Time Passed (Throttle)"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, we only want our systems to run on specific intervals. We can\r\nuse the ",(0,s.jsx)(n.code,{children:"timePassed"})," condition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Planck = require("@packages/Planck")\r\n\r\nlocal Scheduler = Planck.Scheduler\r\nlocal timePassed = Planck.timePassed\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    :addRunCondition(systemA, timePassed(10)) -- Run every 10 seconds\n'})}),"\n",(0,s.jsxs)(n.p,{children:["It's important to note that ",(0,s.jsx)(n.code,{children:"systemA"})," will still be ran on\r\n",(0,s.jsx)(n.code,{children:"RunService.Heartbeat"}),". Our time will tick up until it reaches the given\r\ninterval when the event fires again."]}),"\n",(0,s.jsx)(n.h3,{id:"run-once",children:"Run Once"}),"\n",(0,s.jsx)(n.p,{children:"In Planck, we have Startup Phases built-in. You might want to recreate\r\nsomething akin to these if you're not using the built-in Phases."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Planck = require("@packages/Planck")\r\n\r\nlocal Scheduler = Planck.Scheduler\r\nlocal runOnce = Planck.runOnce\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    :addRunCondition(systemA, runOnce()) -- Run only once\n'})}),"\n",(0,s.jsx)(n.h3,{id:"on-event",children:"On Event"}),"\n",(0,s.jsx)(n.p,{children:"We might want to run a system only when there are any new events since last\r\nframe."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Planck = require("@packages/Planck")\r\n\r\nlocal Scheduler = Planck.Scheduler\r\nlocal onEvent = Planck.onEvent\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    -- Run out system only when there is a new Player\r\n    :addRunCondition(systemA, onEvent(Players.PlayerAdded))\n'})}),"\n",(0,s.jsx)(n.p,{children:"It is important to note that we don't actually collect the events using\r\nthis condition. You will have to do that yourself."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Players = game:GetService("Players")\r\n\r\nlocal Planck = require("@packages/Planck")\r\n\r\nlocal onEvent = Planck.onEvent\r\nlocal hasNewEvent, collectEvents = onEvent(Players.PlayerAdded)\r\n\r\nlocal function systemA()\r\n    for i, player in collectEvents() do\r\n        -- Do something\r\n    end\r\nend\r\n\r\nreturn {\r\n    system = systemA,\r\n    runConditions = { hasNewEvent }\r\n}\n'})}),"\n",(0,s.jsxs)(n.admonition,{title:"Cleaning Up Events",type:"tip",children:[(0,s.jsxs)(n.p,{children:["If you would like to cleanup the event connection that the ",(0,s.jsx)(n.code,{children:"onEvent"})," condition uses,\r\nyou can get the disconnect function like so."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Planck = require("@packages/Planck")\r\n\r\nlocal onEvent = Planck.onEvent\r\nlocal hasNewEvent, collectEvents, getDisconnectFn = onEvent(Players.PlayerAdded)\r\n\r\nlocal disconnect = getDisconnectFn()\r\ndisconnect() -- Event is no longer connected\n'})}),(0,s.jsxs)(n.p,{children:["If you use ",(0,s.jsx)(n.code,{children:"scheduler:removeSystem()"})," to remove a system, all of it's conditions\r\nwill be cleaned up with it, so long as the condition is not being used for any\r\nother system, phase, or pipeline."]})]}),"\n",(0,s.jsx)(n.h4,{id:"defining-events",children:"Defining Events"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Planck.onEvent"})," supports many different ways of defining events. Some provide full typechecking,\r\nwhile others don't."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Types"}),(0,s.jsx)(n.th,{}),(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"Typechecked"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RBXScriptSignal"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Planck.onEvent(Players.PlayerAdded)"})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Instance, RBXScriptSignal"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Planck.onEvent(Players, Players.PlayerAdded)"})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Instance, string"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'Planck.onEvent(Players, "PlayerAdded")'})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2715"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SignalLike"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Planck.onEvent(mySignal)"})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table, string"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'Planck.onEvent(t, "connect")'})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2715"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"table, method"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Planck.onEvent(t, t.connect)"})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"function"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Planck.onEvent(connect)"})}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\u2713"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"not",children:"Not"}),"\n",(0,s.jsx)(n.p,{children:"This is a really simple condition, it just inverses the condition passed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local Planck = require("@packages/Planck")\r\n\r\nlocal Scheduler = Planck.Scheduler\r\nlocal onEvent = Planck.onEvent\r\nlocal isNot = Planck.isNot\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    -- Run our system only when there is a new Player\r\n    :addRunCondition(systemA, isNot(onEvent(Players.PlayerAdded)))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"ideas-for-conditions",children:"Ideas for Conditions"}),"\n",(0,s.jsx)(n.h3,{id:"player-alive",children:"Player Alive"}),"\n",(0,s.jsx)(n.p,{children:"In Roblox, we typically have a Player with a Humanoid. It might make sense\r\nto only run some systems when the Player is alive."}),"\n",(0,s.jsx)(n.p,{children:"Here's a write up for what that might look like for a client system,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Player singleton\r\nlocal LocalPlayer = world:component()\r\nworld:set(LocalPlayer, LocalPlayer)\r\nworld:set(LocalPlayer, Health, 100)\r\n\r\nlocal function playerAlive()\r\n    return function(world)\r\n        local health = world:get(LocalPlayer, Health)\r\n\r\n        if health > 0 then\r\n            return true\r\n        else\r\n            return false\r\n        end\r\n    end\r\nend\r\n\r\nlocal scheduler = Scheduler.new(world)\r\n    -- Run the system only when the Player is alive\r\n    :addRunCondition(systemA, playerAlive())\n"})}),"\n",(0,s.jsx)(n.p,{children:"This helps us to avoid unnecessarily running systems that only have behavior\r\nwhen the Player is alive."}),"\n",(0,s.jsx)(n.h2,{id:"run-conditions-are-not-dependencies",children:"Run Conditions Are Not Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Your systems should ",(0,s.jsx)(n.em,{children:"not"})," depend on conditions. In the context of your\r\nsystem, it should not matter whether a Run Condition is true or false,\r\nthe system should work."]}),"\n",(0,s.jsx)(n.p,{children:"The purpose of Run Conditions are to minimize the amount of systems that\r\nare running during a frame, by cutting out systems which do not need to\r\nrun in a given moment."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},l=i.createContext(s);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);