"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[935],{8798:e=>{e.exports=JSON.parse('{"functions":[{"name":"timePassed","desc":"A Throttle condition which checks whether the amount of\\ntime given has passed or not.\\r","params":[{"name":"time","desc":"Time in seconds","lua_type":"number"}],"returns":[{"desc":"","lua_type":"hasTimePassed () -> boolean"}],"function_type":"static","source":{"line":22,"path":"src/planck/src/conditions.luau"}},{"name":"runOnce","desc":"Checks whether the condition has been called once before\\r","params":[],"returns":[{"desc":"","lua_type":"hasRanOnce () -> boolean"}],"function_type":"static","source":{"line":39,"path":"src/planck/src/conditions.luau"}},{"name":"onEvent","desc":"Checks for any new events and allows for the collection of\\nthose events.\\\\\\n\\\\\\nRead [OnEvent](../docs/design/conditions#on-event) for more information.\\r","params":[{"name":"instance","desc":"","lua_type":"RBXScriptSignal | Instance | SignalLike<...any> | GenericTable | ((Callback<U...>,...any) -> ...any)"},{"name":"event","desc":"","lua_type":"(RBXScriptSignal | string | (...any) -> ())?"}],"returns":[{"desc":"","lua_type":"hasNewEvent () -> boolean"},{"desc":"","lua_type":"collectEvents () -> () -> (number, U...)"},{"desc":"","lua_type":"getDisconnectFn () -> () -> ()"}],"function_type":"static","source":{"line":107,"path":"src/planck/src/conditions.luau"}},{"name":"isNot","desc":"Inverses a given condition.\\r","params":[{"name":"condition","desc":"","lua_type":"() -> boolean"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"inverseCondition () -> boolean"}],"function_type":"static","source":{"line":174,"path":"src/planck/src/conditions.luau"}}],"properties":[],"types":[],"name":"Conditions","desc":"Conditions can be used in systems or as Run Conditions.\\r","source":{"line":15,"path":"src/planck/src/conditions.luau"}}')}}]);